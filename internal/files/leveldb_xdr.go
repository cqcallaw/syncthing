// ************************************************************
// This file is automatically generated by genxdr. Do not edit.
// ************************************************************

package files

import (
	"bytes"
	"io"

	"github.com/calmh/xdr"
)

/*

fileVersion Structure:

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                                                               |
+                       version (64 bits)                       +
|                                                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Length of node                         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                                                               /
\                    node (variable length)                     \
/                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


struct fileVersion {
	unsigned hyper version;
	opaque node<>;
}

*/

func (o fileVersion) EncodeXDR(w io.Writer) (int, error) {
	var xw = xdr.NewWriter(w)
	return o.encodeXDR(xw)
}

func (o fileVersion) MarshalXDR() []byte {
	return o.AppendXDR(make([]byte, 0, 128))
}

func (o fileVersion) AppendXDR(bs []byte) []byte {
	var aw = xdr.AppendWriter(bs)
	var xw = xdr.NewWriter(&aw)
	o.encodeXDR(xw)
	return []byte(aw)
}

func (o fileVersion) encodeXDR(xw *xdr.Writer) (int, error) {
	xw.WriteUint64(o.version)
	xw.WriteBytes(o.node)
	return xw.Tot(), xw.Error()
}

func (o *fileVersion) DecodeXDR(r io.Reader) error {
	xr := xdr.NewReader(r)
	return o.decodeXDR(xr)
}

func (o *fileVersion) UnmarshalXDR(bs []byte) error {
	var br = bytes.NewReader(bs)
	var xr = xdr.NewReader(br)
	return o.decodeXDR(xr)
}

func (o *fileVersion) decodeXDR(xr *xdr.Reader) error {
	o.version = xr.ReadUint64()
	o.node = xr.ReadBytes()
	return xr.Error()
}

/*

versionList Structure:

 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                      Number of versions                       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
/                                                               /
\              Zero or more fileVersion Structures              \
/                                                               /
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+


struct versionList {
	fileVersion versions<>;
}

*/

func (o versionList) EncodeXDR(w io.Writer) (int, error) {
	var xw = xdr.NewWriter(w)
	return o.encodeXDR(xw)
}

func (o versionList) MarshalXDR() []byte {
	return o.AppendXDR(make([]byte, 0, 128))
}

func (o versionList) AppendXDR(bs []byte) []byte {
	var aw = xdr.AppendWriter(bs)
	var xw = xdr.NewWriter(&aw)
	o.encodeXDR(xw)
	return []byte(aw)
}

func (o versionList) encodeXDR(xw *xdr.Writer) (int, error) {
	xw.WriteUint32(uint32(len(o.versions)))
	for i := range o.versions {
		_, err := o.versions[i].encodeXDR(xw)
		if err != nil {
			return xw.Tot(), err
		}
	}
	return xw.Tot(), xw.Error()
}

func (o *versionList) DecodeXDR(r io.Reader) error {
	xr := xdr.NewReader(r)
	return o.decodeXDR(xr)
}

func (o *versionList) UnmarshalXDR(bs []byte) error {
	var br = bytes.NewReader(bs)
	var xr = xdr.NewReader(br)
	return o.decodeXDR(xr)
}

func (o *versionList) decodeXDR(xr *xdr.Reader) error {
	_versionsSize := int(xr.ReadUint32())
	o.versions = make([]fileVersion, _versionsSize)
	for i := range o.versions {
		(&o.versions[i]).decodeXDR(xr)
	}
	return xr.Error()
}
